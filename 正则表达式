定义正则：
var re = new RegExp('a');  //RegExp对象。参数就是我们想要制定的规则。
var re = /a/;  //简写方法 推荐使用 性能更好  不能为空 不然以为是注释

常用方法：
1.test() : 在字符串中查找符合正则的内容，若查找到返回true,反之返回false
  用法：正则.test(字符串) 
  例：var str = '321';
    var re = /\D/;  // \D代表非数字
    console.log(re.test(str));  
常用规则：
\s: 空格
\S: 非空格
\d: 数字
\D: 非数字
\w: 字符 ( 字母 ，数字，下划线_ )
\W: 非字符例子：是否有不是数字的字符
.（点）——任意字符
\.:真正的点
\b : 独立的部分 （ 起始，结束，空格 ）
\B : 非独立的部分
量词：
{n,m}: 至少出现n次，最多m次
{n,}: 至少n次
* : 任意次 相当于{0,}
? : 零次或一次 相当于{0,1}
+ : 一次或任意次相当于 {1,}
{n}: 正好n次
^ : ^n 匹配任何开头为 n 的字符串
?= : ?=n匹配任何其后紧接指定字符串 n 的字符串
?! : ?!n匹配任何其后没有紧接指定字符串 n 的字符串
| : 或运算符

2.search() : 字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置），
             如果搜索失败就返回 -1
  用法：字符串.search(正则)
  在字符串中查找复合正则的内容。忽略大小写：i——ignore（正则中默认是区分大小写的 如果不区分大小写的话，在正则的最后加标识 i ）
  例：var str = 'Accbf';
      var re = /B/i; 或 var re = new RegExp('B','i');
      console.log(str.search(re));

3.match() : 在字符串中搜索复合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null
  用法：字符串.match(正则)
  量词：+ 至少出现一次 匹配不确定的次数（匹配就是搜索查找的意思）
  全局匹配：g——global（正则中默认，只要搜索到复合规则的内容就会结束搜索 ）
  例：var str = 'haj123sdk54hask33dkhalsd879';  // 每次匹配至少一个数字  且全局匹配  如果不是全局匹配，当找到数字123，它就会停止了。
      var re = /\d+/g; //+ 让连续的数字为一个数据项
      console.log(str.match(re));  //["123", "54", "33", "879"]
      
 4.replace() : 查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容
   用法：字符串.replace(正则,新的字符串/回调函数)（在回调函数中，第一个参数指的是每次匹配成功的字符）
   例：var str = "我爱北京天安门，天安门上太阳升。";
       var re = /北京|天安门/g;  // 找到北京 或者天安门 全局匹配
       var str2 = str.replace(re,'*');
       console.log(str2); //我爱**，*上太阳升 
       
exec()方法：和match方法一样，搜索符合规则的内容，并返回内容，格式为数组。
   用法：正则.exec(字符串)；
   属性：input(代表要匹配的字符串)   
   
[] ： 表示某个集合中的任意一个，比如 [abc] 整体代表一个字符 匹配 a b c 中的任意一个，也可以是范围，[0-9] 范围必须从小到大。
[^a] 整体代表一个字符 ：^写在[]里面的话，就代表排除的意思
      
