添加、删除、替换、插入到某个节点的方法：
obj.appendChild()
obj.insertBefore()
obj.remove()
obj.replace()

哪些操作会造成内存泄漏：
setTimeout() 第一个参数是字符串而不是函数的时候就会造成内存泄漏
闭包
循环

正则：

深拷贝，浅拷贝:
浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。
数组的拷贝：
  直接赋值的方式就是浅拷贝；
  深拷贝：Array.prototype.slice(),Array.prototype.concat();
对象的拷贝：
  复制一个对象（把一个对象赋值给另一个对象）叫浅拷贝，指向的是同一个对象
  深拷贝：
  把一个对象的属性复制给另一个对象的属性
  递归拷贝
  使用Object.create()方法

算法：

递归、冒泡的应用场景：
冒泡的应用场景，事件代理
递归的应用场景，深拷贝

判断js数据类型的方法：
typeof、instanceof、constructor、Object.prototype.toString、jQuery方法：$.type()
typeof 适合判断基本数据类型，包含五种数据类型：number、string、boolean、undefined、object、function
instanceof 判断指定对象是否是某个构造函数的实例，由于instanceof对整个原型链上的对象都有效，因此同一个实例对象，
           可能会对多个构造函数都返回true
constructor 所有实例对象都有constructor属性，constructor属性指向prototype对象所在的构造函数，就是说指向创建这个实例的构造函数。
            constructor在通过原型链继承的时候，会出错，需要手动使constructor指向自己
Object.prototype.toString.call([]); //"[object Array]"
Object.prototype.toString.call(""); //"[object String]"
Object.prototype.toString.call(null); //"[object Null]"
Object.prototype.toString.call(undefined); //"[object Undefined]"
Object.prototype.toString.call(1); //"[object Number]"
Object.prototype.toString.call(true); //"[object Boolean]"
Object.prototype.toString.call(function(){}); //"[object Function]"
Object.prototype.toString.call({}); //"[object Object]"
Object.prototype.toString.call(new Date()); //"[object Date]"
// toString方法返回反映这个对象的字符串

this指向问题：
普通函数调用，指向window
对象的方法调用，指向对象
构造器方法调用，指向构造函数实例出来的对象
call(),apply(),bind()改变this指向，this指向第一个参数
注意：函数返回值是一个对象时，this指向这个对象，函数返回值为空或数值，this指向不改变

new操作符到底干了什么：
创建一个对象
将构造函数的作用域赋值给新对象（所以this指向了这个新对象）
执行构造函数的代码（为这个新对象添加属性）
返回新对象

事件代理/事件委托：
原理使用dom冒泡，将事件绑定到父元素上，让父元素进行监听，通过e.target属性，提高性能

ajax请求：
创建一个xhr对象 var xhr = new XmlHttpRequest();
创建请求 xhr.open('get',url,true);
发送请求 xhr.send(null);

浏览器请求过程：
DNS解析
TCP连接
发送HTTP请求
服务器处理请求并返回HTTP请求
浏览器解析渲染页面
连接结束

浏览器部分：
GET和POST方法的区别：
get主要从服务器获取资源，post主要向服务器发送数据
get传输数据通过URL请求，数据在传输过程中是可见的，post对用户不可见
get传输数据量小，因为受到URL长度限制，单效率高，post能上传的数据量大
post比get要安全一些

递归拷贝代码：
function deepClone(initalObj, finalObj) {    
  var obj = finalObj || {};    
  for (var i in initalObj) {        
    var prop = initalObj[i];        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况
    if(prop === obj) {            
      continue;
    }        
    if (typeof prop === 'object') {
      obj[i] = (prop.constructor === Array) ? [] : {};            
      arguments.callee(prop, obj[i]);
    } else {
      obj[i] = prop;
    }
  }    
  return obj;
}
var str = {};
var obj = { a: {a: "hello", b: 21} };
deepClone(obj, str);
console.log(str.a);

写过哪些插件：
轮播图，tab页切换，日历表控件，分页，移动端滑动加载事件，进度条，拖拽控件

移动端触屏事件：

mouseover和mouseend的区别：
